package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"
)

func checkExistingRecord(db *sql.DB, cveID string, currentDate string) (bool, int, error) {
	query := `SELECT version, to_char(date_updated, 'YYYY-MM-DD"T"HH24:MI:SS') as date_updated FROM cve.cve_details WHERE cve_id = $1 ORDER BY version DESC LIMIT 1`
	var version int
	var dateUpdated string
	err := db.QueryRow(query, cveID).Scan(&version, &dateUpdated)
	if err != nil {
		if err == sql.ErrNoRows {
			return false, 0, nil // No record exists
		}
		return false, 0, err
	}
	return dateUpdated == currentDate, version, nil // Record exists, return if dates match and the current version
}

// insertJSONData inserts a JSON object into the PostgreSQL database
func insertJSONData(db *sql.DB, cveID string, jsonData []byte, version int, dateUpdated string) error {
	query := `INSERT INTO cve.cve_details (cve_id, cve_data, version, date_updated) VALUES ($1, $2, $3, $4)`
	_, err := db.Exec(query, cveID, jsonData, version, dateUpdated)
	return err
}


func traverseAndStoreJSONFiles(db *sql.DB, basePath string) error {
	fileCounter := 0
	exclusions := map[string]bool{
		"delta.json":    true,
		"deltaLog.json": true,
	}

	err := filepath.Walk(basePath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}

		// Check if the file is a JSON file and not in the list of excluded files
		filename := filepath.Base(path)
		if filepath.Ext(filename) == ".json" && !exclusions[filename] {
			fileCounter++
			data, err := os.ReadFile(path)
			if err != nil {
				return err
			}

			var jsonObj map[string]interface{}
			if err := json.Unmarshal(data, &jsonObj); err != nil {
				return err
			}

			// Use the file name without extension as the cve_id
			cveID := strings.TrimSuffix(filename, filepath.Ext(filename))
			currentDate := getCurrentDate(jsonObj)
            
			exists, version, err := checkExistingRecord(db, cveID, currentDate)
			if err != nil {
				return err
			}
			if exists {
				fmt.Println("No operation needed, duplicate data.")
				return nil // Duplicate data, do nothing
			}

			if version != 0 {
				version++ // New version of an existing record
			} else {
				version = 1 // New record
			}

			if err := insertJSONData(db, cveID, data, version, currentDate); err != nil {
				return err
			}

			fmt.Printf("%d\n", fileCounter)
		}
		return nil
	})

	return err
}

func getCurrentDate(jsonObj map[string]interface{}) string {
	const layout = "2006-01-02T15:04:05" // Base layout for the current time

	if metaData, ok := jsonObj["cveMetadata"].(map[string]interface{}); ok {
		if dateStr, ok := metaData["dateUpdated"].(string); ok {
			// Find the last colon which precedes the seconds
			lastColon := strings.LastIndex(dateStr, ":")
			if lastColon != -1 && len(dateStr) > lastColon+3 {
				// Trim the string to the format "YYYY-MM-DDTHH:MI:SS"
				return dateStr[:lastColon+3]
			}
			// Return the date string as is if it doesn't match the expected pattern
			return dateStr
		}
	}

	// Return the current time formatted to the specified layout, without fractional seconds
	return time.Now().Format(layout)
}
